# malloc-lab

## 무엇을 배웠나요?
* 가상메모리는 커널 메모리, 스택, 힙, 데이터, 코드(텍스트)로 나누어진다.
* malloc은 그 중 힙 공간을 할당받는 C표준 라이브러리 함수이다.
* malloc을 호출하면, 힙 공간의 경계인 brk 포인터가 증가하는 방향으로 늘어나 공간을 할당한다.
* malloc은 직접적인 시스템 콜은 아니며, 메모리를 할당하는 시스템 콜에는 mmap이 있다.
* malloc과 같은 할당기를 구현하는 데는 여러 이슈가 있는데, 그 중 주요한 것은 내부/외부 단편화를 줄이는 것이다.
* 메모리 할당기에는 malloc과 같은 명시적 할당기가 있고, garbage collector라고도 불리는 묵시적 할당기가 있다.
* 할당받는 블록의 단위를 결정하는 것이 중요하다. 32비트 모드에서는 8바이트 단위로 정렬해 할당한다.

## 주요 키워드별 질문 정리

#### Q1. 어떤 할당기가 좋은 할당기인가요?
요청에 대한 응답이 빠를수록 좋은 할당기이다. 또한 힙 총량 대비 할당받은 총량의 비율, 즉 메모리 이용도가 높을수록 좋은 할당기이다.

#### Q2. 할당기의 요구사항에는 무엇이 있나요?
1. 요청 순서에 관계없이 처리되어야 한다.
2. 요청에 즉시 응답해야 한다.
3. 힙 공간만 사용한다.
4. 정렬 요건에 맞춰 블록을 정렬한다.
5. 할당되어 있는 블록은 수정하지 않는다.

#### Q3. 내부 단편화란 무엇인가요? 외부 단편화란 무엇인가요?
내부 단편화는 정렬 등의 이유로 인해 필요한 것보다 많은 공간을 할당받는 것이다. 즉, 할당받은 공간을 모두 사용하지 않는 현상이다. 외부 단편화는 가용 공간이 작은 조각들로 나누어져 있어 충분한 연속 공간을 확보하지 못하는 현상을 말한다.

#### Q4. 32비트 모드에서 8바이트 단위로 블록을 정렬하는 이유는 무엇인가요?
32비트 모드에서 primitive type의 최대 크기가 8바이트이므로, 8바이트로 블록을 정렬할 시 모든 primitive type의 데이터를 담을 수 있게 된다. 즉, 8바이트는 모든 primitive type 데이터를 담을 수 있는 충분조건이다. 따라서 블록은 8바이트보다 커질 필요가 없게 된다. 또한, 8바이트 미만으로 정렬하게 될 경우 블록의 크기가 작아져 외부 단편화의 위험이 증가한다. 64비트 모드에서는 최대 primitive type 크기가 16바이트이므로, 블록 정렬의 단위가 16바이트가 되겠다.

#### Q5. CSAPP에서 제시한 할당기 구현 방법은 어떤 것이 있나요? 각각의 차이는 무엇인가요?
묵시적 가용 리스트, 명시적 가용 리스트, 분리 가용 리스트, 버디 시스템 등이 있다. 묵시적 가용 리스트는 현재 블록의 크기와 블록의 시작 주소를 이용해 다음 블록의 시작 주소를 계산함으로써 블록들을 연결한다. 명시적 가용 리스트는 각 블록이 다음 블록의 시작 주소를 명시적으로 가지고 있다. 분리 가용 리스트 방식에서는 가용블록들을 일정 크기 클래스로 나누어 보관함으로서 할당의 효율성을 높인다. 이를테면 2의 제곱수를 기준으로 별도의 리스트를 두는 것이다. 버디 시스템은 전체 메모리를 2의 제곱수 크기로 나누어 관리하는 방식으로, 할당 요청이 들어오면 이분하여 더 작은 블록을 만들어 할당한다. 반대로 두 인접한 블록(버디)이 모두 가용 상태가 되면 이를 하나의 큰 블록으로 합친다.

||Pros|Cons|
|-|-|-|
|Implicit|||
|Explicit|||
|Segregated|||
|Buddy|||

#### Q6. 가용 블록을 찾는 방법에는 어떤 것이 있나요? 각각의 차이는 무엇인가요?
First Fit, Next Fit, Best Fit이 있다. First Fit은 리스트를 순회하다가 사이즈가 맞는 첫 번째 블록을 할당받는다. Next Fit은 마지막으로 할당받은 위치를 저장해두었다가, 해당 위치에서부터 리스트 검색을 다시 시작한다. Best Fit은 전체 리스트에서 할당받을 수 있는 최소의 블록을 찾아 할당받는다. First Fit은 가장 간단하지만 리스트의 앞쪽에 크기가 작은 블록들이 남아 점차 검색 시간이 늘어날 수 있다가는 단점이 있다. Next Fit은 이를 보완할 수 있지만, 메모리 이용도 면에서는 효율이 낮다. Best Fit은 메모리를 가장 효율적으로 이용할 수 있는 방법이지만, 매번 전체 리스트를 검색해야 하여 응답 시간이 증가한다는 단점이 있다.


||Pros|Cons|
|-|-|-|
|First Fit|초기 탐색에서 빠르다.|앞부분에 작은 블록이 축적되어 점차 검색 시간이 증가할 가능성이 높다.|
|Next Fit|마지막 탐색 지점부터 원형 리스트처럼 탐색하므로 First Fit 대비 균일한 분포를 지닐 수 있다.||
|Best Fit|메모리 이용도가 가장 높다.|전체 리스트를 메번 검색해야 하므로 검색 시간이 느리다.|

#### Q7. 할당기 구현에 있어서 이슈는 어떤 것이 있나요?
1. 가용 블록의 구성: 블록마다 어떤 정보를 관리해야 할지 결정해야 한다. 묵시적 리스트에서와 같이 블록의 사이즈와 시작 주소만 갖고 있어도 되고, 명시적 리스트에서와 같이 다음 블록의 시작 주소를 갖고 있어도 된다. 또한 블록의 사이즈가 8바이트로 정렬되어 있으므로, 블록 주소의 마지막 3개 비트는 항상 0이다. 따라서 이를 활용해 블록의 가용 여부 등을 비트로 체크할 수 있다.
2. 배치: 새로운 블록을 할당받을 때 어디를 할당받는 것이 좋을까? 이것을 결정하는 것이 First, Next, Best Fit이다.
3. 분할: 특정 블록을 할당받았을 때, 남는 공간을 어떻게 하는 것이 좋을까? 분할하는 것이 좋을 수도 있지만, 단편화의 위험을 증가시킬수도 있다.
4. 연결: 블록을 할당 해제했을 때, 양옆으로 다른 가용 블록이 있다면 연결시켜주는 것이 좋을까? 더 큰 가용블록을 만든다는 점에서 이점이 있을 수 있겠지만, 크기가 작은 할당 요청이 연속적으로 들어올 경우, 연결-분할의 반복이 오버헤드로 작용할 수도 있다.
        

**그래서 님은 어떤 전략을 사용했나요?**
   
결국 어떤 정책을 사용하는 것이 좋을까? 나는 최종적으로 명시적 리스트로 블록을 구성했으며, 각 블록들을 2의 제곱수 - 크기 클래스로 묶어 여러 개의 리스트로 관리하는 분리 가용 방식을 사용했다. 각 클래스 안에서는 First Fit으로 가용 블록을 찾았다. 이미 클래스가 나누어져 있기 때문에 Best Fit으로 찾지 않아도 어느 정도 효율을 달성할 수 있을 것으로 보았다. 블록을 할당하고, 남는 공간이 있으면 분할 후 해당 크기 클래스의 가용 리스트에 넣어주었고, 할당 해제했을 때 양옆으로 가용 블록이 있다면 연결하였다. 연결의 경우, 특정 할당 요청 패턴 (작은 요청이 반복적으로 와서 분할, 연결이 계속 일어나야 하는 경우) 에서는 불리할 수 있지만, 임의의 예측할 수 없는 요청에 대한 할당기이므로 큰 가용 블록으로 연결함으로서 단편화의 위험을 낮추는 것이 좋을 것으로 생각했다.

**+) 분할 전략의 트레이드오프**
* 장점: 할당 요청에 보다 정밀하게 대응함으로서 보다 효율적으로 메모리를 사용한다.
* 단점: 빈번한 분할은 많은 수의 작은 블록을 생성하므로 외부 단편화의 위험이 증가한다. 또, 관리해야 할 블록 수가 증가하여 메모리 관리 오버헤드가 증가할 수 있다.

**+) 연결 전략의 트레이드오프**
* 장점: 가용 블록을 병합하므로 큰 할당 요청을 수용할 수 있는 능력을 향상시킨다. 이는 단편화를 줄이는 데 도움이 된다.
* 단점: 연결 과정에서 인접한 블록의 가용 상태를 확인하고, 병합하는 과정에서 추가적인 계산과 메모리 접근이 필요하므로 오버헤드가 발생할 수 있다.

#### Q8. 경계 태그란 무엇인가요?
할당을 해제한 후 블록을 연결할 때, 다음 블록뿐 아니라 이전 블록의 가용 여부도 확인해야 한다. 전체 리스트를 모두 검색하지 않게 하기 위해 블록마다 헤더를 복사한 푸터를 갖고 있을 수 있다. 그러면, 한 블록이 할당 해제되었을 때, 시작 주소에서 푸터 사이즈만큼 빼서 이전 블록의 정보에 접근할 수 있게 된다. 이를 경계 태그 Boundary Tag라고 하며, 이를 통해 이전 블록에의 접근을 상수 시간 내에 할 수 있게 된다. 단점으로는 그만큼 메타데이터가 증가함으로서 내부 단편화가 증가한다. 그러나 할당된 블록은 푸터가 없어도 되므로 이를 제외함으로서 이용도를 높일 수 있겠다.

#### Q9. 내부 단편화와 외부 단편화 중 어떤 것이 더 큰 문제가 될까요? 그 이유는?
내부 단편화는 할당된 메모리 블록 내 사용되지 않는 공간을 의미한다. 이는 주로 메모리 블록의 크기가 요청된 크기보다 약간 큰 경우에 발생한다. 반면 외부 단편화는 가용 블록들이 작은 조각들로 분산되어 있어 요청된 크기만큼의 연속적인 메모리 블록을 할당하기 어려운 경우 발생한다. 따라서, 내부 단편화가 특정 블록 내 미사용 공간에 국한되는 반면 외부 단편화는 전체 메모리 공간의 할당 능력에 영향을 미친다. 결과적으로 내부 단편화보다는 외부 단편화가 증가할수록 메모리 자원을 낭비할 가능성이 더 커지고, 시스템 성능에 더 큰 저하를 초래할 수 있다. 또한, 내부 단편화는 일반적으로 블록의 단위를 조정함으로서 방지할 수 있는 반면 외부 단편화는 메모리 재조정이나 가비지 컬렉션과 같은 복잡한 방법을 필요로 한다. 이로 인해 외부 단편화가 더 메모리 관리에서 더 중요한 문제로 간주된다.

