# Red Black Tree

#### Q1. 레드 블랙 트리란 무엇인가요?
트리의 노드가 레드 혹은 블랙으로 색상이 부여되며, 한 노드로부터 자손인 리프 노드로까지 가는 경로에 포함된 블랙 노드의 수가 모두 같다- 와 같은 속성을 만족하는 이진 탐색 트리이다. 이러한 속성을 충족시키는 방향으로 삽입, 삭제 연산이 수행되므로서 자체적으로 균형을 맞추고, 이에 따라 검색에 걸리는 시간복잡도가 $O(\log N)$으로 제한된다.

#### Q2. 레드 블랙 트리의 5개 속성을 말해주세요.
1. 모든 노드는 레드 혹은 블랙이다.
2. 루트 노드는 블랙이다.
3. 리프 노드는 블랙이다.
4. 레드 노드의 자식은 블랙이다.
5. 한 노드로부터 자손인 리프 노드까지 가는 경로에 있는 블랙 노드의 개수가 모두 같다.

#### Q3. 레드 블랙 트리의 삽입 과정을 설명해주세요.
1. 먼저 일반 이진 탐색 트리의 삽입과 동일하게, 루트부터 키값의 대소를 비교하며 삽입 위치를 찾는다.
2. 위치에 삽입한 후, 삽입된 노드의 색을 레드로 지정한다.
3. 만약 레드-블랙 특성이 깨졌으면 복구한다. 위반될 수 있는 특성은 1. 루트가 블랙이어야 한다는 특성과 2. 레드 노드의 자식은 블랙이어야 한다는 속성이다.
3. 만약 부모가 블랙 노드라면 별도의 fixup이 필요하지 않다.
4. 부모가 레드 노드라면, 부모의 부모 노드와 부모의 형제 노드의 색을 파악하고 케이스를 나누어 색을 재지정 recolor하거나, 트리를 회전시켜 특성을 복구한다. 이 과정에서 중요한 점은 fixup 과정에서 부모 노드로 루트까지 레벨을 상승시키며 복구가 진행되기 때문에, 시간복잡도가 $O(\log N)$에 머문다는 것이다.

#### Q4. 레드 블랙 트리의 삭제 과정을 설명해주세요.
일반적인 이진 탐색 트리와 같이 삭제한 후, 레드 블랙 속성이 위반되었다면 복구하는 식으로 진행됩니다.

1. 일반 이진 탐색 트리의 삭제와 동일하게, 삭제되는 노드의 자식 수에 따라 케이스를 나눈다. 자식이 없는 경우 해당 노드를 삭제하고, 자식이 하나인 경우 노드를 삭제하고 자식이 그 자리를 대체한다. 자식이 둘인 경우 오른쪽 서브트리에서 최솟값을 찾거나 왼쪽 서브트리에서 최댓값을 찾아 해당 노드와 교체하고 삭제한다.
2. 삭제되는 노드의 색이 레드인 경우 특성 위반이 없으므로 별도로 fixup하지 않는다. 왜? 레드 노드는 루트 또는 리프가 아니므로 루트/리프의 색에 관한 속성을 깨지 않고, 부모와 자식이 모두 블랙이므로 레드 노드의 자식이 레드인 위반상황이 발생하지 않는다. 또 노드의 흑색 높이에도 영향을 끼치지 않는다.
3. 삭제되는 노드의 색이 블랙인 경우, 속성이 위반될 수 있다. 특히 노드 간 블랙 높이가 달라질 수 있다. 이를 위해 형제 노드, 부모 노드와 색을 비교하여 필요시 삭제된 자리를 대체한 노드에 extra black을 임시로 설정하고, 트리의 루트로 올라가면서 recolor & rotation을 통해 이를 해소하는 식으로 특성을 복구할 수 있다.

#### Q5. 레드 블랙 트리는 어디에 쓰나요?

* 우선순위 큐와 같은 ordered list를 구현하는 데 사용된다.
* 해시 테이블과 함께 키-값 쌍을 저장하는 연관 배열을 구현하는 대표적인 방법이기도 하다.
    * **연관 배열이란?** 키-값 쌍으로 이루어진 추상 자료형. 수학적인 의미에서는 유한한 정의역을 가진 함수. 일반적으로 lookup, insert, delete 와 같은 연산을 지원.
    * **추상 자료형이란?** 자료형*data type*의 수학적 모델로서, 데이터 사용자 관점에서의 행위로 정의된다. 구체적으로는 해당 자료형의 가능한 값과, 연산, 그리고 연산의 동작(behavior)로 구성된다. 구체적인 구현에 대해서는 명시하고 있지 않다는 점에서 자료구조 data structure와는 구분된다.
* 구체적인 사용처는 다음과 같다.
    1. C++의 Standard Template Library (STL)에서 std::set과 std::map을 구현하기 위해 사용된다.
    2. Java의 TreeSet과 TreeMap, HashMap이 사용한다.
    3. Linux Kernel은 Completely Fair Scheduler (CFS)를 구현하기 위해 rbtree를 사용한다. 이 스케줄러는 태스크task를 트리로 표현하며, 다음 태스크를 찾기 위해 rbtree를 쓴다. 각 task는 vruntime (virtual runtime, CPU가 점유된 시간)을 기준으로 트리에 저장되며, 스케줄러는 leftmost 노드를 찾아 스케줄한다.
    4. 가상메모리 관리를 위해서도 쓸 수 있을 것 같다. (pintos에서 supplementary page table을 구현하기 위해 hashmap을 사용했는데, 이거를 tree로 쓸 수 있을 듯.)