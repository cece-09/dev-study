# Garbage Collection

#### Q1. 가비지 컬렉션이란 무엇인가요?
프로그램에 의해 할당되었지만 더 이상 접근되지 않는 메모리를 자동으로 식별하고 반환하는 메모리 관리 기법이다.

#### Q2. 가비지 컬렉션을 지원하는 언어에는 어떤 것이 있나요?
대표적으로 Java가 있다. C#, JavaScript, Python등 대부분의 프로그래밍 언어가 가비지 컬렉션을 지원한다. C언어는 지원하지 않는다.

#### Q3. 가비지 컬렉션의 장점과 단점은?
장점은 사용자 프로그램이 수동으로 메모리 관리를 할 필요가 없어 잘못된 메모리 관리로부터 오는 문제를 효과적으로 예방할 수 있게 된다는 점이다. 이를테면 Dangling Pointer나 Double Free와 같은 프로그래밍 오류들이다. 단점은, 어떤 메모리를 해제할 것인지를 결정하는 것 역시 컴퓨터 자원을 소모하는 일이라는 것이다. 따라서 수동 메모리 관리 대비 성능 면에서 저하가 있을 수 있다.

#### Q4. 가비지 컬렉터는 어떻게 반환할 메모리를 결정하나?
가비지 컬렉터는 할당받은 메모리를 일종의 directed (reachability) graph 형태로 관리한다. 예를 들어 힙 공간에서 메모리를 할당받아 스택 변수 ptr에 저장했다고 하자. 이 경우 ptr과 힙 공간 내 할당받은 메모리의 관계를 간선으로 표현할 수 있다. 메모리 할당 요청이 들어왔는데 가용메모리가 없으면, 운영체제는 GC를 콜해서 해제할 수 있는 메모리가 있는지 확인하기 위해 진입 간선의 존재유무를 살펴본다. 만약 진입 간선이 없는 힙 메모리인 경우, 프로그램에서 더 이상 도달 가능하지 않은 것이므로 할당을 해제할 수 있다.

---

**[🍀 Wikipedia: Garbage Collection](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science))**

### 1. Garbage Collection?
컴퓨터 과학 분야에서 가비지 컬렉션이란 자동화된 메모리 관리 기법이다. 가비지 컬렉터는 프로그램에 의해 할당되었지만 더 이상 접근되지 않는 메모리, 즉 가비지garbage를 반환reclaim하기를 시도한다. 가비지 컬렉션은 수동 메모리 관리를 단순화하기 위해 1959년경 미국의 컴퓨터 과학자 존 맥카시 John McCathy에 의해 발명되었다.

### 2. Garbage-Collected Language
* 많은 프로그래밍 언어가 언어 사양의 일부로 가비지 컬렉션을 필요로 하거나(예: RPL, Java, C#, D, Go 및 대부분의 스크립팅 언어), 실제 구현을 위해 효과적으로(예: lambda calculus과 같은 형식적 언어) 가비지 컬렉션을 필요로 한다. 이를 garbage-collected language라고 한다.
* C와 C++같은 언어들은 수동으로 메모리 관리하도록 설계되었지만, garbage-collected 구현이 가능하도록 지원한다.
* Ada, Modula-3, C++/CLI와 같은 언어들에서는 가비지 컬렉션과 수동 메모리 관리가 별도의 분리된 힙을 사용함으로서 하나의 같은 어플리케이션 안에 공존할 수 있다.
* 반면 D와 같은 언어는 garbage-collected 언어이지만 사용자가 객체를 수동으로 삭제할 수 있고, 심지어는 속도가 필요할 때 가비지 컬렉션 자체를 비활성화할 수 있도록 허용한다.

### 3. Pros and Cons
#### 장점
사용자 프로그램이 수동으로 메모리 관리를 할 필요가 없다. 이는 다음과 같은 문제들을 효과적으로 방지한다.
* Dangling Pointers: 메모리 자원이 해제되었거나 소멸된 이후에도 포인터가 여전이 그 주소를 가리키는 경우 발생한다. 이를 역참조하는 경우 예상치 못한 문제를 일으킬 수 있다.
* Double free bugs: 이미 해제된 메모리 자원을 다시 해제하는 경우 발생한다.
* Memory Leaks: 메모리가 할당되었지만, 더 이상 필요하지 않음에도 해제되지 않는 경우. 사용되지 않는 메모리가 누적되어 시스템 성능이 저하된다.

#### 단점
GC는 해제할 메모리를 결정하기 위해 컴퓨터 자원을 소모한다. 따라서, 소스코드에서 객체의 라이프사이클을 수동으로 관리하지 않는 편의성의 대가는 오버헤드로, 프로그램의 성능을 저하시킬 수 있다.

2005년에 발표된 동료 검토 논문에 따르면 GC가 이러한 오버헤드를 보완하고 이상적인 명시적 메모리 관리를 사용하는 동일한 프로그램만큼 빠르게 수행하려면 5배의 메모리가 필요하다고 결론지었습니다. 그러나 이 비교는 프로파일러에서 실행되는 프로그램에서 트레이스를 수집하여 구현된 오라클을 사용하여 할당 해제 호출을 삽입하여 생성된 프로그램과 비교한 것으로, 이 프로그램은 프로그램의 특정 실행에 대해서만 정확합니다. 메모리 계층 효과와의 상호작용으로 인해 이러한 오버헤드는 예측하거나 일상적인 테스트에서 감지하기 어려운 상황에서 견딜 수 없는 수준이 될 수 있습니다. 성능에 미치는 영향은 가비지 컬렉션이 가장 바람직한 기능임에도 불구하고 iOS에서 가비지 컬렉션을 채택하지 않는 이유로 애플이 제시했습니다.
