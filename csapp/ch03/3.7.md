
## 3.7. 프로시저
**👀 What is Procedure?** 지정된 인자들과 리턴값으로 특정 기능을 구현하는 코드 블록. 프로시저는 함수, 메소드, 서브루틴, 핸들러 등 다양한 모습을 띤다.

프로시저는 기계어 수준에서 어떻게 번역되고 동작하는가?

프로시저 P가 프로시저 Q를 호출하고, Q가 종료되면 다시 P로 리턴되는 상황을 가정해보자.
* 제어권 전달 Passing Control: PC는 진입할 때 Q에 대한 코드의 시작주소로 설정되고, 리턴할 때는 P에서 Q를 호출하는 인스트럭션 다음의 인스트럭션으로 설정되어야 한다.
* 데이터 전달 Passing Data: P는 하나 이상의 매개변수를 Q에 제공하고, Q는 다시 P로 하나의 값을 리턴한다.
* 메모리 할당과 반납 (De)Allocating memory: Q는 시작할 때 지역변수를 위한 공간을 할당할 수도 있고, 리턴할 때 이를 반납할 수 있다. (링크드 리스트의 free_all과 같은 함수를 생각해 보자.)

### 3.7.1 런타임 스택
**👀 런타임 스택이란?** 프로그램이 실행 중 사용되는 메모리 영역. 프로시저 P가 Q를 호출할 때, P는 일시적으로 정지한다. 그리고 Q가 종료되면 P가 다시 실행된다. 이는 가장 최근에 (늦게) 호출된 프로시저를 먼저 처리한 후 이전의 프로시저로 되돌아가는 방식이므로, 후입선출 Late in First out의 자료구조인 스택을 사용하게 된다. 이때 '스택과 프로그램 레지스터는 제어와 데이터를 전송하기 위해, 메모리를 할당하기 위해 필요한 정보를 저장한다.' 이를 런타임 스택이라 한다.

![runtime_stack](https://blog.wxk.me/2017/09/05/stack-frame/csapp_big.jpg)
<small>런타임 스택과 스택 프레임: 스택 top이 그림의 아래에 있는 것에 유의하라.</small>

**👀 스택 프레임이란?** 프로시저가 레지스터에 저장될 수 있는 크기 이상의 메모리를 요구할 때 공간을 스택에 할당한다. 이를 스택 프레임이라고 한다. 즉, 스택 프레임은 개별 프로시저가 호출될 때 생성되어 지역변수, 인자, 반환 주소나 제어 정보를 저장하는 고정 크기의 메모리 블록이다.

+) 고정 크기의 블록을 할당받는데, 만약 그 이상이 필요하면 어떻게 되는가?

### 3.7.2. 제어의 이동 Passing Control
제어를 이동한다는 것은 곧 **프로그램 카운터를 Q를 위한 코드의 시작 주소로 넘기는 것** 을 의미한다. Q가 종료되고 나면, 위 그림에서 Q의 스택 프레임 위에 있는 Return Address로 돌아가 남은 인스트럭션을 실행하게 된다.

#### `call`의 과정: P가 Q를 호출했다. 무슨 일이 발생?
1. call Q 인스트럭션 바로 다음 인스트럭션의 주소 A를 스택에 push
2. 스택포인터가 감소하여 새로운 스택 프레임을 위한 공간 확보
3. 프로그램 카운터를 Q의 시작 부분으로 이동
4. 제어가 이동되었다. Q를 실행하면서 지역변수, 제어 정보 등이 스텍 프레임에 저장되고 사용됨
5. Q가 종료되면 (`ret`을 만나면) 스택에서 주소 A를 pop
6. (P의 실행이 재개되어야 할) 주소 A로 이동하여 P실행

|Instruction||
|-|-|
|call $Label$|procedure call|
|call $*Operand$|procedure call|
|ret|return from call|

`call`은 직접 또는 간접적으로 프로시저를 호출할 수 있다. (간접은 프로시저의 시작 위치 주소값을 오퍼랜드로 갖는다.)


#### 🔥 제어 전달의 예제 [꼭 해보기]
main에서 top을 호출하고, top에서 다시 leaf를 호출하는 형태이다.

```as
// Disassembly of leaf(long y)
// y in %rdi
0000000000400540 <leaf>:
  400540: 48 8d 47 02        lea 0x2(%rdi),%rax  //L1: z+2
  400544: c3                 retq                // L2: Return
```

```as
// Disassembly of top(long x)
// x in %rdi
0000000000400545 <top>:
  400545: 48 83 ef 05        sub $0x5,%rdi        // T1: x-5
  400549: e8 f2 ff ff ff     callq 400540 <leaf>  // T2: Call leaf(x-5)
  40054e: 48 01 c0           add %rax,%rax        // T3: Double result
  400551: c3                 retq                 // T4: Return
  ...
  // Call to top from function main
  40055b: e8 e5 ff ff ff     callq 400545 <top>   // M1: Call top(100)
  400560: 48 89 c2           mov %rax,%rdx        // M2: Resume
```
top 프로시저의 실행을 추적해보자
|Label|PC|Instruction|%rdi|%rax|%rsp|*%rsp|
|-|-|-|-|-|-|-|
|M1|0x40055b|callq|100|-|0x7fffffffe820|-|
|T1|0x400545|sub|100|-|0x7fffffffe818|0x400560|
|T2|0x400549|add|95|-|0x7fffffffe818|0x400560|
|L1|0x400540|lea|95|-|0x7fffffffe810|0x40054e|
|L2|0x400544|retq|-|97|0x7fffffffe810|0x40054e|
|T3|0x40054e|add|-|97|0x7fffffffe818|0x400560|
|T4|0x400551|retq|-|194|0x7fffffffe818|0x400560|
|M2|0x400560|mov|-|194|0x7fffffffe820|-|


+) x86-64 아키텍처에서 일반적으로 스택 포인터는 `%rsp`, 프로그램 카운터는 `%rip` 레지스터에 저장된다.

### 3.7.3. 데이터 전송
프로시저를 호출하면, 제어 뿐 아니라 인자를 통해 데이터 역시 전달된다. 이는 주로 레지스터를 이용해 이루어진다.

#### 01) 데이터 전달: 프로시저 P가 프로시저 Q를 호출했다. 무슨 일이 발생?
1. P는 인자를 적절한 레지스터에 복사한다.
2. Q를 실행하고, 값을 리턴하면 이 역시 레지스터에 저장된다.
3. P는 저장된 리턴값을 꺼내어 나머지 인스트럭션을 실행한다.

#### 02) 인자를 모두 레지스터에 저장 못하면?
x86-64에서는 최대 6개의 함수 인자가 레지스터에 저장될 수 있다. 만약 인자의 타입이 64비트가 아닌 32비트라면, 32비트 레지스터 (ex. %edi)에 저장될 수도 있다. 만약 인자가 6개를 넘어가면, **메모리상의 런타임 스택으로 전달된다.**

그렇다면 스택에서는 무슨 일이 일어날까? 먼저 6개를 초과하는 인자부터 마지막 인자까지 (7~N) 저장할 수 있는 크기를 스택 프레임 안에 할당한다. 그리고 인자를 스택 탑으로 push한다. **인자가 배치되고 나면 비로소 P에서 Q로 제어를 전달하는 call이 실행된다.** 

+) 인자를 할당하는 과정에서 모든 데이터 길이는 8의 배수로 반올림된다. 이유는?

만약 Q가 또다시 6개가 넘는 인자를 갖는 함수를 호출할 경우, 이 인자들은 위 런타임 스택 그림의 Argument build area에 공간이 할당된다.

### 3.7.4 스택에서의 지역저장공간
지역 데이터가 메모리에 저장되어야 하는 경우들이 있다. 이럴 때 런타임 스택을 사용하고, 이 공간을 위 스택 그림의 'Local Variables'에서 찾아볼 수 있다.

#### 스택에 Local Variable저장이 필요한 경우
1. 지역 데이터를 저장하기에 레지스터 수가 충분치 않은 경우
2. 지역변수에 연산자 '&'가 사용되어 변수의 주소를 생성해야 하는 경우
3. 일부 지역변수가 배열 또는 구조체여서 이들이 배열이나 구조체 참조로 접근되어야 하는 경우

### 3.7.5. 레지스터를 이용하는 지역저장소
프로시저 P가 프로시저 Q를 호출했을 때, P를 실행하면서 레지스터에 저장된 값들은 보존되어야 한다. 따라서 Q는 P가 나중에 사용해야 하는 레지스터 값은 덮어쓰지 않는다. 이를 위해 x86-64는 레지스터를 사용하는 일종의 규칙/관습을 채택한다.

관습적으로 %rbx, %rbp, %r12-r15는 피호출자-저장 레지스터로 구분된다.
* Q는 저장된 값을 변경하지 않는다.
* 또는 저장된 원래 값을 스택프레임 안에 넣고 그것을 변경한다.
<small>함수에서 main함수에서 선언한 변수의 값을 call by value 인자로 받아 변경했을 때, 다시 main으로 돌아오면 값이 변경되지 않았음을 기억하는지? 그 얘기다.</small>

* 이 레지스터 값을 저장하는 곳이 스택그림에서의 Saved Register다.

### 3.7.6. 재귀 프로시저
함수를 재귀적으로 호출하는 것 역시 다른 경우와 마찬가지로 처리된다. 즉, 함수 안에서 불린 함수는 (비록 그 이름은 같을지라도) 기계수준에서 서로 다른 함수로 처리된다. 각 함수를 위한 스택 프레임이 별도로 생성되므로, 재귀함수가 동작할 수 있게 된다.