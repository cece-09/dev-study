# Network

## What is Network?
* 모뎀이나 LAN, 케이블, 무선 매체 등 통신 설비를 갖춘 컴퓨터로 서로 연결하는 조직, 체제, 통신망
* 두 개 이상의 장치가 서로 통신할 수 있는 상태로 연결되어 있으면 네트워크.
* 통신의 구성요소는 수신자, 발신자, 연결매체 (medium), 규약 (protocol), 메시지이다.

**👀 헷갈리는 용어 정리**<br/>
* 패킷: 데이터를 자른 것. 통상적으로 헤더+데이터+트레일러. 네트워크 계층 이상에서만 사용. 왜냐, IP주소를 갖고 있어야 함.
* 대역폭
* 프로토콜: 번역어는 통신규약. 어떻게 정보를 교환할 것인가에 대한 규칙 또는 약속
* 인터페이스: 단말, 망 등 상호간을 접속하는 조건. 서로 정보를 교환하기 위한 접점 또는 경계. 프로토콜에 의해, 인터페이스가 결정될 수 있다.
* 연결지향: 연결을 하고, 보내고, 연결을 해제
* 비연결지향: 연결 설정/해제가 없이 그냥 연속적으로 보냄
* 투명성: 경로 및 전달의 일관성을 제공하는 것. 실제 경로를 드러내지 않는 가상의 일관된 경로를 구성하는 것?
* 회선 교환 네트워크
* 패킷 교환 네트워크
* 전이중, 반이중
* LAN은 호스트와 호스트를 연결하고, WAN은 연결장치끼리 연결한다.
* 링크와 채널? FDM, TDM..

## OSI: Open System Interconnection
1983, ISO, 개방형 시스템 간 상호 접속

### 1. 계층화
OSI는 네트워크 상호 접속을 위해 다양한 규격을 개발하는 **공통 기반**이다. 그런데 왜 나누는가? 일종의 기본 틀을 제공하는 역할을 한다. 한 계층의 변경이 다른 계층으로 영향을 주지 않는다.

물리 - 데이터링크 - 네트워크 - 전송 - 세션 - 표현 - 응용 계층으로 나뉜다. 상위 레이어는 하위 레이어에게 서비스를 받는다. 각 계층은 상위 레이어로 데이터를 보내기 전, 가급적 오류를 방지하기 위한 방법을 사용한다.

**👀 그래서 각 계층이 뭘 하는 것 같은가?**
1. Physical: 전기 신호로서의 데이터의 전송
2. Data-Link: 프레임으로서의 데이터의 노드 간 전송
3. Network: 데이터그램으로서의 데이터를 서브네트워크 간 전송
4. Transport: 세그먼트로서의 데이터를 프로세스 간 전송
5. Session: 프로세스 간 세션을 생성, 유지, 종료
6. Presentation: 시스템 간 데이터를 표기하는 문법을 맞춤
7. Application: 메시지로서의 데이터를 사용자 간 전송
<br/><br/>

|Layer|Data|연결대상|기능|
|-|-|-|-|
|Physical|비트, 주파수|device|신호변환, 오류처리, 전송모드|
|Data Link|Frame|Node|주소지정, 흐름제어, 다중접근제어|
|Network|Datagram, Packet|Host?|경로제어(라우팅), 주소체계, 연결/비연결|
|Transport|Segment|Process|프로세스연결, 투명성, 세션제어, 신뢰성, 다중화, 지연보상|
|Session|Message, Data|Process|세션관리, 대화관리, 다중화, 그룹화, 범주화|
|Presentation|Message, Data|Process|암호화, 압축, 코드변환, 가상터미널규약?|
|Application|Message, Data|User|사용자 상호작용~|

### 2. 캡슐화와 역캡슐화

### 3. 멀티플렉싱

### 4. Physical Layer
digital/analog signal을 대상으로 한다. 이 신호를 물리적으로 전달하기 위한 규약을 정의한다. 물리적인 오류를 최소화하기 위해 다양한 방법들을 사용한다. (증폭 등)

**👀 데이터 전송 성능을 어떻게 평가할까?**
* 대역폭
* 스로풋
* 지터

#### 1) 신호 규격의 정의
전송 속도(비트율)와 신호의 레벨을 정한다. 얼마나 빨리 신호를 전달할 것인가? 즉 한번에 얼마나 많은 비트를 보내나 (얼마나 높은 주파수 대역을 사용하나)?
🔥

#### 2) 신호의 인코딩/디코딩
일련의 비트가 동축케이블, 트위스티드 페어 케이블 등으로 전송된다고 하면, 신호를 펄스 형태로 바꿔야 한다. 또는 광섬유를 쓴다면, 빛을 켜고 끔을 반복함으로서 이산적인 신호를 보낼 수 있기 때문에, 적합한 디지털 신호로 바꿔야 한다. 마찬가지로, 전파를 통해 전송된다면 아날로그 신호로 바꾸게 된다.. 전파를 통해 들어온 신호도 디지털로 바꿔야 비트로 바꾼다. 이러한 신호의 변환이 인코딩/디코딩에 속한다고 볼 수 있고, 이것이 물리 계층의 이슈가 된다.

* **Digital→Analog**: 반송파를 만든 다음, 신호를 만들어내기 위해 진폭, 주파수, 또는 위상을 변조한다. 차례로 ACM, FCM, PCM (-편이 변조)
* 디지털 신호를 디지털 신호로 변환: 라인코딩, 블록코딩, 스크램블링이 있다. 블록코딩과 스크램블링은 오류 감지 기능을 포함하는 변환인데, 이는 신호의 전달에서 다양한 오류(감쇠, 크로스토크, 왜곡)이 발생하는 것을 대비하기 위함이다.
* 아날로그 신호를 디지털 신호로 변환: 펄스 부호 변조 (신호를 등급으로 표본화한다음 계수화, 부호화한다.) 델타 변조 등
* 아날로그 신호를 아날로그 신호로 변환: AM, FM, PM


#### 3) 비트 동기
* 클럭이란? 타이밍 신호/동기 신호로, 동작하는 순간을 제어하기 위한 시간 정보이다. 얘를 잘 가지고 가야 디지털 신호를 유지할 수 있다. 얘를 어떻게 할 것인지의 표준을 정의한다. 여러 가지 방식이 있다..

#### 4) 전송매체 규격
매체의 종류나 토폴로지의 규격을 정의한다.
* 유도매체: 트위스티드페어, 동축케이블, 광섬유케이블
* 비유도매체: 전파, 마이크로파, 적외선

#### 5) 물리적 회선 관리
* 모뎀: 
* 리피터, 허브: 리피터는 감쇠 등의 통신장애에 대응하기 위해 신호를 증폭시킨다. 허브는 ??

### 5. Data-Link Layer
네트워크에서 내려온 패킷에 적힌 주소를 보고, 주소에 도착하기 위해 어디로 가야 하는지 찾아서 보내준다. 이 구현방법이 다양하다. 주요 프로토콜으로 이더넷이 있다.

ARP, HDLC를 알고싶다.

#### 1) 프레이밍
프레이밍이란? 전송의 시작과 끝을 알리고, 프레임 경계를 짓는 것. 비트 스트림에서 '여기서부터 여기까지가 정보임'을 알리기 위해 프레임을 식별할 수 있도록 해야 한다. 그래서 프레임 비트를 삽입하거나 프레임 식별을 위한 비트를 앞뒤로 붙인다. 또는 프레임을 보내는 정확한 시간간격을 유지하는 방식도 있다. (SONET)

그래서 정확히 어떻게 프레임을 구성하나? (내려갈 때) 네트워크 계층에서 받은 데이터에 헤더와 트레일러를 붙인다. 헤더는 출발노드와 도착노드 등의 주소가 들어가고, 트레일러에는 오류탐지를 위한 리던던시가 들어간다. 올라갈 때도 마찬가지로, 물리계층에서 받은 비트스트림에서 프리앰블과 오류 탐지 비트(FCS)를 통해 오류를 감지하고 확인을 보내는 등..의 에러제어를 한다.

**👀 이더넷 프레임 구조**<br/>
![ethernet_frame](https://upload.wikimedia.org/wikipedia/commons/thumb/4/42/Ethernet_frame.svg/300px-Ethernet_frame.svg.png)

#### 2) 흐름제어
보내는 측과 받는 측 간의 속도 차를 보상한다. 송신하는 측이 수신하는 측보다 더 빨리 데이터를 보내지 못하게 제어한다. 이때 송신을 제어 (아직 못 받았으면 더 보내지 않도록 하기, Stop-and-Wait) 할 수도 있고, 전송률을 기반으로 흐름을 제어할 수도 있다. 여러 개의 프레임을 동시에 보내고, 오류 여부를 응답받아 다시 보내주는 방법도 있다.

#### 3) 에러제어
전송 오류에 대응하는 규약을 정의한다. 오류 검출이란 정확히 말하자면 '전송 중 발생한 오류의 존재 여부만을 수신측이 알 수 있도록 하는 기술'이다. 검출하는 방법부터 대응하는 방법까지를 규약 정의.

📌 수신측은 오류를 어떻게 탐지할까?
* CRC: 순환 중복 코드
* Checksum: 검사합
* Parity Check: 패리티 비트 (..)

📌 송신측은 오류를 어떻게 알까?
* 수신측이 CRC, Checksum 등의 방식을 통해 오류를 체크하고, NAK신호를 보낸다.
* 만약 신호가 일정 시간 동안 안 온다면, 오류라고 판단할수도 있다.

📌 오류를 탐지하면 어떻게 할까?
* 오류를 탐지하면 재전송을 요청한다.<br/>
→ **ARQ (Automatic Repeat Request)** 검출 후 재전송 방식

  1. **Stop and Wait**: 하나를 보내고, 확인(ACK)받고, 다시 보낸다
  2. **Go Back n**: 여러 개를 보낸다. NAK을 받으면, 그 패킷부터 다시 보낸다.
  3. **Selective Repeat**: 여러 개를 보낸다. NAK을 받으면, 그 패킷만 다시 보낸다. (그럼 재정렬은? 버퍼를 이용해 한다) →TCP에서 이렇게 한다.

* 오류를 탐지하면 수정한다.<br/>그러려면 송신측에서 오류를 고칠 수 있도록 원본 데이터에 대한 충분한 정보를 먼저 보내줘야 한다. (그니까 원본 데이터가 무엇이었는지를 추론할 수 있도록) 당연히 손상/손실이 무한대로 일어나는 경우까지는 대비하기 어렵다. 그러나 오류의 수가 오류정정능력 한계에 있는 경우, 굳이 NAK을 보내고..하면서 비용을 쓰기보다는 복구하는게 나은 경우도 있다. 그러려면 오류 정정 능력, 즉 내가 몇 비트까지 오류를 정정할 수 있는지 바운더리를 먼저 알아야겠다..
  1. 단일 비트 에러 정정: 해밍 부호
  2. 다중 비트 에러 정정: BCH 부호, RS부호

#### 4) 순서화
일련의 프레임을 여러 경로로 나누어 보내는 패킷 교환 네트워크를 생각해보자. 프레임은 순서대로 도착하지 않는다. 따라서 도착한 프레임을 재조립하는 (재정렬하는) 일은 수신측의 몫이 된다. 이를 위해 송신측은 프레임에 순서를 부여해서 (0~max) 순서가 역전되는 일을 방지한다.

#### 5) 데이터링크 연결 관리
노드는 양끝 호스트와 중간의 라우터다. 그 사이를 연결하는 (추상화된) 선을 링크라고 한다. **지점 간 링크(Point-to-Point, 점대점)**는 노드 쌍 간의 연결이다. 만약 노드가 다른 하나의 노드에만 전송한다면 유니캐스팅이다. **브로드캐스트 링크**는 네트워크의 모든 장치가 공유하는 통신 채널이다. 모든 장치에서 전송되고, 모든 장치에서 수신.

이더넷에서는 MAC주소의 모든 비트가 1인 FF:FF:FF:FF:FF:FF가 브로드캐스트 주소다. 하나의 노드가 이 주소로 보내면, 다른 모든 노드가 수신한다. 
브로드캐스팅을 하려면 결국 하나의 LAN에 속하는 모든 호스트가 어떻게든 (스위치, 허브, AP, .. 와 같은 장치의 사용을 포함하여) 연결되어 있어야 한다.

##### Network Topology: 브로드캐스팅이 항상 가능?
![network_topology](https://assets-global.website-files.com/620d42e86cb8ec4d0839e59d/6230eed9d9792f3709c5ffd6_5f1086baa37c842a30184650_network-topology-types-diagram.png)
LAN은 주로 스위치 또는 허브를 포함하는 스타 토폴로지, WAN은 메쉬형 토폴로지를 사용한다.

* **Circuit Switch**: 특정 시간에, 하나의 노드 쌍이 채널?을 독점한다.
  * 연결 지향적 Connection-oriented: 연결설정/전송/해제의 과정이 있다.
  * 채널을 독점하므로 비효율적이다. 연결 설정을 하고, 전송을 안 한다면..?
  * 하지만 지금 연결설정된 두 노드간의 전송은 지연이나 재정렬 없이 바로바로 이루어지게 된다.
  * 주로 메쉬형 네트워크에서 사용된다. (다른 토폴로지는?)
* **Packet Switch Datagram**: 패킷이 출발부터 도착까지 다 다른 경로를 타고 간다.
  * 무연결 Connectionless: 연결 설정 과정이 없다.
  * 패킷은 모두 무관한 것으로 취급하고, 스위치 내의 라우팅 테이블을 활용해 패킷을 보낼 경로를 정한다.
  * 채널을 독점하지 않으므로 여러 전송을 동시적?으로 처리한다. 이점은 효율적이지만 그렇다보니 패킷이 교환기에서 대기하는(쌓이는)경우가 생겨 지연이 발생한다. 그리고 패킷이 순서대로 도착함을 보장하지 못하므로 재정렬해야 한다.
* **Virtual Circuit Switch**: 데이터를 패킷으로 쪼갠다. 그렇지만 모두 동일한 경로를 타고 순차적으로 도착한다.
  * 서킷교환처럼 연결 지향적이다.
  * 데이터를 분할해 패킷으로 나눈다. 그런데 여기에 가상회선 식별자 Virtual Circuit Identifier (VCI)를 하나 붙여서, 이 패킷들이 동일한 그룹으로 묶여야 함을 나타낸다. 그러면 스위치는 가상회선 식별자 테이블을 보고 패킷을 어떤 경로로 보낼지 결정하게 된다.
  * 가상회선은 특정 상황에 전송 도중 변경될 수도 있다.
  * 가상회선 식별자 테이블은 어떻게 만들어질까?
    * 최초로 VCI와 함께 패킷이 도착하면, 스위치는 패킷을 어디로 보냈는지를 기록한다.
    * 그리고 다음 패킷이 도착하면, VCI테이블을 검색해서 어떤 경로로 보낼지를 결정한다.
    * 가상회선이 연결 해제되면, 해당 VCI를 가진 행은 삭제할 수 있다.

**👀 리소스 부족으로 VCI테이블 행을 삭제했는데 해당 VCI를 가진 패킷이 들어왔다!**<br/>
1. 스위치는 이것을 새로운 연결의 시작으로 본다. 새로운 경로를 확인한다.
2. 이렇게 되면 패킷의 도착 순서가 꼬여서 수신측이 재정렬하기도 한다. (주로 버퍼를 이용해서)

#### 6) 매체접근제어 MAC
다중 프로세스 환경에서.. 어떻게 할 건지.. 알로하, 코드분할다중접근, 주파수분할다중접근, 시분할다중접근

### 6. Network Layer
인터넷에서 서브네트워크 간을 연결한다. 그니까 데이터링크층은 호스트와 호스트 간의 연결이었지만, 네트워크층은 네트워크와 네트워크의 연결에 관심이 있다.
#### 1) 경로제어(라우팅)
하나의 네트워크에서 다른 네트워크로 가는 최적의 경로를 수행한다. 그러려면 다른 네트워크의 주소가 필요한데 이것이 IP address 이다. 네트워크층에서는 IP주소를 헤더에 담아 패킷을 만든다.

패킷이 라우터로 나가면, 각 라우터에서는 목적지까지 최단경로로 가기 위한 정책적인 결정을 하게 된다. 라우터는 라우팅 테이블을 가지고 있는데, 이 테이블의 구성이 매우 중요해진다.

여러 기준으로 라우팅을 구분한다.
  1. 고정 Fixed/Static: 미리 경로가 정해져있다.
  2. 동적 Dynamic/Adaptive: 네트워크 상태에 따라 경로가 선택된다.
  3. 홍수 라우팅/플러딩: 수신 경로 이외의 모든 경로로 전파한다.
  4. 랜덤 라우팅: 무작위로 경로를 선택한다.
  5. 소스 라우팅: 경로를 패킷 헤더에 넣어둔다.
  6. 계층적 라우팅: 네트워크를 계층적으로 나눈다. → 라우팅 테이블 항목을 줄인다.

#### 2) 논리적 주소체계 부여
IP 주소를 부여한다.
* IP주소는 전세계, 지역/대륙별, 국가, ISP, 개인별로 할당/분배/등록 등 관리될 수 있다.
* IP주소 관리를 DHCP서버가 한다.
* IP주소의 접두어에 따라 서브넷이 달라진다. 특정 기능을 수행하기 위해 예약된 주소도 있다. (IPv4의 브로드캐스팅 주소와 같이)

#### 3) 연결지향성 및 비연결성 서비스 제공

### 7. Transport Layer
데이터 링크 과정에서는 물리적인 전송 장애에 대응한다. 따라서 라우터로부터 각 호스트까지 정확한 정보과 왔는지 확인할 수 있다. 하지만 라우팅 과정 자체에 문제가 있다면 어떻게 대응할 수 있을까? 이를 위해 전송 계층에서는 신뢰성 있는 통신이 이슈가 된다.

* 프로세스와 프로세스 간을 연결하며, 데이터 단위는 세그먼트이다.

#### 1) 신뢰적 전송
동일 또는 이기종 시스템간에 어떤 망이 어떻게 연결되었든 간에 관계없이 정보를 틀림없이 상대 단말기에 전달. 이때 수립된 두 양단 프로세스 간의 논리적인 연결을 세션이라고 할 수 있음..?

#### 2) 다중화/역다중화
동시에 여러 개의 논리적 연결을 가능하게 하는 다중화 기법 사용. 하나의 매체에 여러 신호를 결합시켜 보낸다. 따라서 받는 쪽에서는 이 신호들을 구분해야 한다. 그게 역다중화. 주파수분할, 파장분할, 시분할, 공간분할, 코드분할 다중화가 있다.

#### 3) TCP
전송 계층의 프로토콜. 양단 프로세스 간 다중 연결 식별이 가능함. 연결 지향적. 소켓 주소(IP주소+포트번호)를 통해 프로세스를 식별. 각 TCP연결마다 독립적으로 관리됨.

##### Handshaking
* 송신측이 SYN을 보냄. 수신측이 SYN+ACK을 보냄. 송신측이 ACK을 보냄 → 연결설정
* 송신측이 FIN을보냄. 수신측이 ACK를보냄. 수신측이 FIN+ACK를보냄. 송신측이 ACK를보냄. → 연결해제

##### 가상회선과 연결 지향적
패킷이 올바른 순서로 전송되고 수신되는 것을 보장하기 위한 논리적인 연결. 스위치마다 VCI 테이블을 가지고 있는 네트워크의 경우 (즉, 3계층이 가상회선을 지원하는 경우) 가 있을 수 있고, 또는 순서대로 오류 없이 중복 없이 전송하기 위해 수신측에 버퍼를 사용하거나 재정렬하는 메커니즘을 사용할 수 있음. TCP가 '가상회선을 사용한다'고 말하기에는 무리가 있고, '연결 지향적이다'라고 표현.

#### 4) UDP
연결성이 없음. 단지 1개의 소켓 구조만 있으면 됨.

### 8. Session Layer
세션이란? 두 시스템 간의 통신을 위해 설정된 연결(전송을 추상화함?) 일정 시간 동안 유지되는 상태와 정보를 갖게 됨. 이를 확인하기 위해, 즉 내가 이 세션의 참여자임을 알리기 위해 세션 키 (session key)라는 식별자를 교환함.

세션 계층에서는 세션을 설정, 해제, 관리하는 기능을 한다. 에러에 대응할 수 있도록 중간 동기점을 삽입하여 메시지를 대화 단위로 그룹화한다.

### 9. Presentation Layer

### 10. Application Layer
